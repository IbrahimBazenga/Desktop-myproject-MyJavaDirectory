<HTML>
<HEAD>
<TITLE>COS 226: Final Exam</TITLE></HEAD>
<BODY>
<TABLE WIDTH="100%" BORDER="0">
<TR ALIGN="LEFT" VALIGN="BOTTOM">
<TD><STRONG>NAME:</STRONG><BR><BR><BR><BR>
<STRONG><FONT SIZE="+2">Final Exam</FONT></STRONG></TD>
<TD ALIGN="RIGHT" VALIGN="BOTTOM">
<STRONG>COS 226 Solutions, Spring 2010
</STRONG></TD></TR></TABLE>
<hr>
<ol>
<li>MST  
<pre>A. 65 42 39 36 34 33 30 22 
B. 22 36 42 65 39 34 33 30  
</pre>

<li>KMP 
<pre>
    0 1 2 3 4 5 6 7 8
A   0 0 3 0 0 0 3 0 9
E   0 2 0 4 0 6 0 8 0
T   1 1 1 1 5 1 7 1 1
    T E A E T E T E A
</pre>

<li> DFS trace  
<ol type="A"><li>       <br>
<img src="spr10/spr10-dfs.png" width=25% height=25%>          
<li>Adjacency lists 
<pre>
0: 1 2 
1: 2 0 
2: 3 1 
3: 0 1 
</pre>
 
<li><pre>
 dfs(3) 
   dfs(0) 
     dfs(1) 
      dfs(2) 
        check 3 
        check 1 
      2 done  
    check 0 
    1 done  
  check 2
  0 done  
check 1 
3 done 
</pre>
</ol>
<li>Acronyms 
<table>
<tr><td>Abstract machine, basis for KMP algorithm.</td>
<td>DFA</td>
</tr>
<tr><td>Data structure for implementing symbol tables.</td>
<td>BST</td>
</tr>
<tr><td>Substring-search algorithm.	 </td>
<td>KMP </td>
</tr>
<tr><td>Fundamental recursive method.	     </td>
<td>DFS</td>
</tr>
<tr><td>For single-source shortest paths in unweighted graphs.</td>
<td>BFS</td>
</tr>
<tr><td>Symbol table-based compression algorithm.   </td>
<td>LZW</td>
</tr>
<tr><td>Fundamental search problem, from logic.	      </td>
<td>SAT</td>
</tr>
<tr><td>Abstract machine, basis for grep     </td>
<td>NFA</td>
</tr>
</table>

<p><li>LZW compression  
<pre>
in:   B   A   N   D   A   N   A   B   A   N   A   N   A    
out:  42  41  4E  44   82     41   81     4E     85      80 
</pre> 
 
<pre> 
key    value 
BA       81 
 
AN       82 
 
ND       83 
 
DA       84 
 
ANA      85 
 
AB       86 
 
BAN      87 
 
NA       88
</pre>

<li>Suffix TST <br>
<img src="spr10/spr10-suffix.bmp">

<!--- #7
--->          
<li>String symbol table - optional answers in brackets 
 
<pre>
 CD     R-ary trie 
 A[BE]  BST 
 A[DE]	TST 
 A[BE]	red-black tree
</pre>

<p><li>
RE pattern matching I 
<img src="spr10/spr10-re.png">
<p><li>RE pattern matching II 
<pre>D
</pre>
<p><li> 7 sorting algorithms 
<pre>G A B F C D E
</pre>
<p><li> Graph algorithms 
<pre>F, DE, A, C, E, B, AF
</pre

<p><li> Graph space usage. 
<pre>
At start of Graph constructor = 16,  
after Graph constructor = 32 + 16V 
Total memory usage for graph with V vertices and E edges  = 32 + 16V + 56E

Node: 28 bytes (8 bytes overhead, 4 bytes Item pointer, 4 bytes Node pointer, 12 bytes Integer).
Nodes: 56E (2 nodes per edge)
</pre>
<p><li> Analysis  
<pre>
~N and ~N 
~N and ~N/2 
~N and 0 
~2N and ~N/4 
~2N and ~3N/8 
~2N and 0
</pre>
<p><li> Tree encoding 
<p>A. <br>
<img src="spr10/spr10-tree.bmp">
<P>B. 
<pre>For all i from 1 to N-1  the number of 0s must be greater than the number of 1s. 
At the end the number of 1s must be one greater than the number of 0s.
</pre>
<p><li> Burrows-Wheeler 
<pre>
A. sIndex[c+1] - sIndex[c]
B. tCount[c, last] - tCount[c, first-1]
C. sIndex[c] + tCount[c, first-1]
D. sIndex[c] + tCount[c, last] - 1
E. Calculate sIndex and tCount. Make s the last character of the query string.
Set first and last equal to the first and last index of this character using
sIndex. Iteratively work from back to front of query string updating first 
and last using answers from C and D.
</pre>
<p><li> Hard problem identification
<pre> A B C G H</pre>

